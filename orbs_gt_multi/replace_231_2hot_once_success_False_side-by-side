							      |	extern void exit();
# include <stdio.h>						# include <stdio.h>
							      |	void Caseerror();
typedef char   bool;						typedef char   bool;
# define false		0					# define false		0
# define true		1					# define true		1
							      |	# define NULL		0
# define MAXSTR		100					# define MAXSTR		100
# define MAXPAT		MAXSTR					# define MAXPAT		MAXSTR
# define ENDSTR		'\0'					# define ENDSTR		'\0'
# define ESCAPE		'@'					# define ESCAPE		'@'
# define CLOSURE	'*'					# define CLOSURE	'*'
# define BOL		'%'					# define BOL		'%'
# define EOL		'$'					# define EOL		'$'
# define ANY		'?'					# define ANY		'?'
# define CCL		'['					# define CCL		'['
# define CCLEND		']'					# define CCLEND		']'
# define NEGATE		'^'					# define NEGATE		'^'
# define NCCL		'!'					# define NCCL		'!'
# define LITCHAR	'c'					# define LITCHAR	'c'
# define DITTO		-1					# define DITTO		-1
# define DASH		'-'					# define DASH		'-'
# define TAB		9					# define TAB		9
# define NEWLINE	10					# define NEWLINE	10
# define CLOSIZE	1					# define CLOSIZE	1
typedef char	character;					typedef char	character;
typedef char	string[MAXSTR];					typedef char	string[MAXSTR];
bool								bool
get_line(s, maxsize)						get_line(s, maxsize)
char *s;							char *s;
							      |	int maxsize;
{								{
	char *result;							char *result;
	result = fgets(s, maxsize, stdin);				result = fgets(s, maxsize, stdin);
	return (result != NULL);			      |		                       ;
}								}
							      |	int
addstr(c, outset, j, maxset)					addstr(c, outset, j, maxset)
char c;								char c;
char *outset;							char *outset;
int *j;								int *j;
							      |	int maxset;
{								{
	bool result;							bool result;
	if (*j >= maxset) {						if (*j >= maxset) {
		result = false;							result = false;
	} else{								} else{
		outset[*j] = c;							outset[*j] = c;
		*j = *j + 1;							*j = *j + 1;
		result = true;							result = true;
	}								}
	return (result);						return (result);
}								}
char								char
esc(s, i)							esc(s, i)
char *s;							char *s;
int *i;								int *i;
{								{
	char result;							char result;
	if (s[*i] != ESCAPE) {						if (s[*i] != ESCAPE) {
		result = s[*i];							result = s[*i];
	} else {if (s[*i + 1] == ENDSTR) {		      |		} else {if (s[*i + 1] == ENDSTR) ;
		result = ESCAPE;			      |
	} else{						      |		  else{
		*i = *i + 1;							*i = *i + 1;
		if (s[*i] == 'n') {						if (s[*i] == 'n') {
			result = NEWLINE;						result = NEWLINE;
		} else {if (s[*i] == 't') {		      |			} else {if (s[*i] == 't') ;
			result = TAB;			      |
		} else{					      |			  else{
			result = s[*i];							result = s[*i];
		}}								}}
	}}								}}
	return (result);						return (result);
}								}
void change();							void change();
							      |	void
dodash(delim, src, i, dest, j, maxset)				dodash(delim, src, i, dest, j, maxset)
char delim;							char delim;
char *src;							char *src;
int *i;								int *i;
char *dest;							char *dest;
int *j;								int *j;
							      |	int maxset;
{								{
	int k;								int k;
	bool junk;							bool junk;
	char escjunk;							char escjunk;
	while ((src[*i] != delim) && (src[*i] != ENDSTR)) {		while ((src[*i] != delim) && (src[*i] != ENDSTR)) {
		if (src[*i - 1] == ESCAPE) {		      |			if (src[*i - 1] == ESCAPE) ;
			escjunk = esc(src, i);		      |
			junk = addstr(escjunk, dest, j, maxse |
		} else {if (src[*i] != DASH)    {	      |			  else {if (src[*i] != DASH)    {
			junk = addstr(src[*i], dest, j, maxse				junk = addstr(src[*i], dest, j, maxse
		} else {if ((*j <= 1) || (src[*i + 1] == ENDS |			} else {if ((*j <= 1) || (src[*i + 1] == ENDS
			junk = addstr(DASH, dest, j, maxset); |
		} else {if ((isalnum(src[*i - 1])) && (isalnu |			  else {if ((isalnum(src[*i - 1])) && (isalnu
		    (src[*i - 1] <= src[*i + 1])) {				    (src[*i - 1] <= src[*i + 1])) {
			for (k = src[*i-1]+1; k <= src[*i+1];				for (k = src[*i-1]+1; k <= src[*i+1];
				junk = addstr(k, dest, j, max					junk = addstr(k, dest, j, max
			}								}
			*i = *i + 1;			      |				           ;
		}else      {				      |			}else      ;
			junk = addstr(DASH, dest, j, maxset); |
		}}}}					      |			 }}}
		(*i) = (*i) + 1;						(*i) = (*i) + 1;
	}								}
}								}
bool								bool
getccl(arg, i, pat, j)						getccl(arg, i, pat, j)
char *arg;							char *arg;
int *i;								int *i;
char *pat;							char *pat;
int *j;								int *j;
{								{
	int jstart;							int jstart;
	bool junk;							bool junk;
	*i = *i + 1;					      |		           ;
	if (arg[*i] == NEGATE) {			      |		if (arg[*i] == NEGATE) ;
		junk = addstr(NCCL, pat, j, MAXPAT);	      |
		*i = *i + 1;				      |
	} else{						      |		  else{
		junk = addstr(CCL, pat, j, MAXPAT);				junk = addstr(CCL, pat, j, MAXPAT);
	}								}
	jstart = *j;							jstart = *j;
	junk = addstr(0, pat, j, MAXPAT);		      |		                                ;
	dodash(CCLEND, arg, i, pat, j, MAXPAT);				dodash(CCLEND, arg, i, pat, j, MAXPAT);
	pat[jstart] = *j - jstart - 1;					pat[jstart] = *j - jstart - 1;
	return (arg[*i] == CCLEND);			      |		                          ;
}								}
void								void
stclose(pat, j, lastj)						stclose(pat, j, lastj)
char *pat;							char *pat;
int *j;								int *j;
							      |	int lastj;
{								{
	int jt;								int jt;
	int jp;								int jp;
	bool junk;							bool junk;
	for (jp = *j - 1; jp >= lastj; jp--) {				for (jp = *j - 1; jp >= lastj; jp--) {
		jt = jp + CLOSIZE;						jt = jp + CLOSIZE;
		junk = addstr(pat[jp], pat, &jt, MAXPAT);			junk = addstr(pat[jp], pat, &jt, MAXPAT);
	}								}
	*j = *j + CLOSIZE;						*j = *j + CLOSIZE;
	pat[lastj] = CLOSURE;						pat[lastj] = CLOSURE;
}								}
bool in_set_2(c)						bool in_set_2(c)
char c;								char c;
{								{
	return (c == BOL || c == EOL || c == CLOSURE);			return (c == BOL || c == EOL || c == CLOSURE);
}								}
bool in_pat_set(c)						bool in_pat_set(c)
char c;								char c;
{								{
	return (c == LITCHAR || c == BOL || c == EOL || c ==  |		;
	       c == CCL || c == NCCL || c == CLOSURE);	      |		                                              
}								}
							      |	int
makepat(arg, start, delim, pat)					makepat(arg, start, delim, pat)
char *arg;							char *arg;
							      |	int start;
char delim;							char delim;
char *pat;							char *pat;
{								{
	int result;							int result;
	int i, j, lastj, lj;						int i, j, lastj, lj;
	bool done, junk;						bool done, junk;
	bool getres;							bool getres;
	char escjunk;							char escjunk;
	j = 0;								j = 0;
	i = start;					      |		         ;
	lastj = 0;					      |		         ;
	done = false;							done = false;
	while ((!done) && (arg[i] != delim) && (arg[i] != END		while ((!done) && (arg[i] != delim) && (arg[i] != END
		lj = j;					      |			      ;
		if ((arg[i] == ANY)) {						if ((arg[i] == ANY)) {
			junk = addstr(ANY, pat, &j, MAXPAT);				junk = addstr(ANY, pat, &j, MAXPAT);
		} else {if ((arg[i] == BOL) && (i == start))  |			} else {if ((arg[i] == BOL) && (i == start)) 
			junk = addstr(BOL, pat, &j, MAXPAT);  |
		} else {if ((arg[i] == EOL) && (arg[i+1] == d |			  else {if ((arg[i] == EOL) && (arg[i+1] == d
			junk = addstr(EOL, pat, &j, MAXPAT);				junk = addstr(EOL, pat, &j, MAXPAT);
		} else {if ((arg[i] == CCL)) {					} else {if ((arg[i] == CCL)) {
			getres = getccl(arg, &i, pat, &j);				getres = getccl(arg, &i, pat, &j);
			done = (bool)(getres == false);	      |				                              ;
		}else {if ((arg[i] == CLOSURE) && (i > start)			}else {if ((arg[i] == CLOSURE) && (i > start)
			lj = lastj;			      |				          ;
			if (in_set_2(pat[lj])) {	      |				if (in_set_2(pat[lj])) ;
				done = true;		      |
			} else{				      |				  else{
				stclose(pat, &j, lastj);					stclose(pat, &j, lastj);
			}								}
		}else  {							}else  {
			junk = addstr(LITCHAR, pat, &j, MAXPA				junk = addstr(LITCHAR, pat, &j, MAXPA
			escjunk = esc(arg, &i);						escjunk = esc(arg, &i);
			junk = addstr(escjunk, pat, &j, MAXPA				junk = addstr(escjunk, pat, &j, MAXPA
		}}}}}								}}}}}
		lastj = lj;				      |			          ;
		if ((!done)) {							if ((!done)) {
			i = i + 1;							i = i + 1;
		}								}
	}								}
	junk = addstr(ENDSTR, pat, &j, MAXPAT);				junk = addstr(ENDSTR, pat, &j, MAXPAT);
	if ((done) || (arg[i] != delim)) {		      |		if ((done) || (arg[i] != delim)) ;
		result = 0;				      |
	} else {if ((!junk)) {				      |		  else {if ((!junk)) ;
		result = 0;				      |
	} else{						      |		  else{
		result = i;							result = i;
	}}								}}
	return (result);						return (result);
}								}
							      |	int
getpat(arg, pat)						getpat(arg, pat)
char *arg;							char *arg;
char *pat;							char *pat;
{								{
	int makeres;							int makeres;
	makeres = makepat(arg, 0, ENDSTR, pat);				makeres = makepat(arg, 0, ENDSTR, pat);
	return (makeres > 0);						return (makeres > 0);
}								}
							      |	int
makesub(arg, from, delim, sub)					makesub(arg, from, delim, sub)
char *arg;							char *arg;
							      |	int from;
character delim;						character delim;
char *sub;							char *sub;
{								{
	int result;							int result;
	int i, j;							int i, j;
	bool junk;							bool junk;
	character escjunk;						character escjunk;
	j = 0;						      |		     ;
	i = from;							i = from;
	while ((arg[i] != delim) && (arg[i] != ENDSTR)) {		while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
		if ((arg[i] == (unsigned)('&'))) {	      |			if ((arg[i] == (unsigned)('&'))) ;
			junk = addstr(DITTO, sub, &j, MAXPAT) |
		} else{					      |			  else{
			escjunk = esc(arg, &i);		      |				                      ;
			junk = addstr(escjunk, sub, &j, MAXPA				junk = addstr(escjunk, sub, &j, MAXPA
		}								}
		i = i + 1;							i = i + 1;
	}								}
	if (arg[i] != delim) {				      |		if (arg[i] != delim) ;
		result = 0;				      |
	} else{						      |		  else{
		junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);   |			                                          ;
		if ((!junk)) {				      |			if ((!junk)) ;
			result = 0;			      |
		} else{					      |			  else{
			result = i;							result = i;
		}								}
	}								}
	return (result);						return (result);
}								}
bool								bool
getsub(arg, sub)						getsub(arg, sub)
char *arg;							char *arg;
char *sub;							char *sub;
{								{
	int makeres;							int makeres;
	makeres = makesub(arg, 0, ENDSTR, sub);				makeres = makesub(arg, 0, ENDSTR, sub);
	return (makeres > 0);						return (makeres > 0);
}								}
							      |	void subline();
bool								bool
locate(c, pat, offset)						locate(c, pat, offset)
character c;							character c;
char *pat;							char *pat;
							      |	int offset;
{								{
	int i;								int i;
	bool flag;							bool flag;
							      |		            ;
	i = offset + pat[offset];			      |		                        ;
	while ((i > offset)) {						while ((i > offset)) {
		if (c == pat[i]) {						if (c == pat[i]) {
			flag = true;							flag = true;
			i = offset;							i = offset;
		} else{								} else{
			i = i - 1;							i = i - 1;
		}								}
	}								}
	return (flag);							return (flag);
}								}
							      |	bool
omatch(lin, i, pat, j)						omatch(lin, i, pat, j)
char *lin;							char *lin;
int *i;								int *i;
char *pat;							char *pat;
							      |	int j;
{								{
	char advance;							char advance;
	bool result;							bool result;
	advance = -1;							advance = -1;
	if ((lin[*i] == ENDSTR)) {			      |		if ((lin[*i] == ENDSTR)) ;

	} else{						      |		  else{
		if (!in_pat_set(pat[j])) {		      |			if (!in_pat_set(pat[j])) ;


		} else{					      |			  else{
			switch (pat[j]) {						switch (pat[j]) {
			case LITCHAR:							case LITCHAR:
				if (lin[*i] == pat[j + 1]) {					if (lin[*i] == pat[j + 1]) {
					advance = 1;							advance = 1;
				}								}
				break;			      |					     ;
							      |				case BOL:
							      |					;
							      <
							      <

							      >					 
							      >					     ;
			case ANY:							case ANY:
				if (lin[*i] != NEWLINE) {					if (lin[*i] != NEWLINE) {
					advance = 1;							advance = 1;
				}								}
				break;			      |					     ;
			case EOL:							case EOL:
				if (lin[*i] == NEWLINE) {					if (lin[*i] == NEWLINE) {
					advance = 0;							advance = 0;
				}								}
							      |					     ;
			case CCL:							case CCL:
				if (locate(lin[*i], pat, j + 					if (locate(lin[*i], pat, j + 
					advance = 1;							advance = 1;
				}								}
							      |					     ;
							      |				case NCCL:
				if ((lin[*i] != NEWLINE) && ( |					;
							      |
				}			      |					 
							      |					     ;
							      |				default:
							      |					                 ;
			}								}
		}								}
	}								}
	if ((advance >= 0)) {						if ((advance >= 0)) {
		*i = *i + advance;						*i = *i + advance;
		result = true;							result = true;
	} else{								} else{
		result = false;							result = false;
	}								}
	return (result);						return (result);
}								}
patsize(pat, n)							patsize(pat, n)
char *pat;							char *pat;
							      |	int n;
{								{
	int size;							int size;
	if (!in_pat_set(pat[n])) {			      |		if (!in_pat_set(pat[n])) ;


	} else{						      |		  else{
		switch (pat[n]) {						switch (pat[n]) {
		case LITCHAR:							case LITCHAR:
			size = 2;							size = 2;
			break;								break;
		case BOL:							case BOL:
		case EOL:							case EOL:
		case ANY:							case ANY:
			size = 1;							size = 1;
			break;								break;
		case CCL:							case CCL:
		case NCCL:							case NCCL:
			size = pat[n + 1] + 2;						size = pat[n + 1] + 2;
			break;								break;
		case CLOSURE:							case CLOSURE:
			size = CLOSIZE;							size = CLOSIZE;
							      |				     ;
							      |			default:
							      |				                 ;
		}								}
	}								}
	return (size);							return (size);
}								}
							      |	int
amatch(lin, offset, pat, j)					amatch(lin, offset, pat, j)
char *lin;							char *lin;
							      |	int offset;
char *pat;							char *pat;
							      |	int j;
{								{
	int i, k;							int i, k;
	bool result, done;						bool result, done;
	done = false;							done = false;
	while ((!done) && (pat[j] != ENDSTR)) {				while ((!done) && (pat[j] != ENDSTR)) {
		if ((pat[j] == CLOSURE)) {					if ((pat[j] == CLOSURE)) {
			j = j + patsize(pat, j);					j = j + patsize(pat, j);
			i = offset;							i = offset;
			while ((!done) && (lin[i] != ENDSTR))				while ((!done) && (lin[i] != ENDSTR))
				result = omatch(lin, &i, pat,					result = omatch(lin, &i, pat,
				if (!result) {							if (!result) {
					done = true;							done = true;
				}								}
			}								}
			done = false;							done = false;
			while ((!done) && (i >= offset)) {				while ((!done) && (i >= offset)) {
				k = amatch(lin, i, pat, j + p					k = amatch(lin, i, pat, j + p
				if ((k >= 0)) {							if ((k >= 0)) {
					done = true;							done = true;
				} else{								} else{
					i = i - 1;							i = i - 1;
				}								}
			}								}
			offset = k;							offset = k;
							      |				           ;
		} else {							} else {
			result = omatch(lin, &offset, pat, j)				result = omatch(lin, &offset, pat, j)
			if ((!result)) {						if ((!result)) {
				offset = -1;							offset = -1;
				done = true;							done = true;
			} else{								} else{
				j = j + patsize(pat, j);					j = j + patsize(pat, j);
			}								}
		}								}
	}								}
	return (offset);						return (offset);
}								}
							      |	void
putsub(lin, s1, s2, sub)					putsub(lin, s1, s2, sub)
							      |	char *lin;
							      |	int s1, s2;
char *sub;							char *sub;
{								{
	int i;								int i;
							      >		int j;
							      >		     ;
							      >		;


	while ((sub[i] != ENDSTR)) {			      <
		if ((sub[i] == DITTO)) {		      <





		}					      <

	}						      |		                                                 
}								}
							      |	void
subline(lin, pat, sub)						subline(lin, pat, sub)
char *lin;							char *lin;
char *pat;							char *pat;
							      |	char *sub;
{								{
	int i, lastm, m;						int i, lastm, m;
							      |		          ;
	i = 0;								i = 0;
	while ((lin[i] != ENDSTR)) {					while ((lin[i] != ENDSTR)) {
		m = amatch(lin, i, pat, 0);					m = amatch(lin, i, pat, 0);
							      >			;


							      |			 
							      <
		if ((m == -1) || (m == i)) {					if ((m == -1) || (m == i)) {
							      |				                     ;
			i = i + 1;							i = i + 1;
		} else{								} else{
			i = m;								i = m;
		}								}
	}								}
}								}
							      |	void
change(pat, sub)						change(pat, sub)
char *pat, *sub;						char *pat, *sub;
{								{
	string line;							string line;
	bool result;							bool result;
	result = get_line(line, MAXSTR);				result = get_line(line, MAXSTR);
	while ((result)) {						while ((result)) {
		subline(line, pat, sub);					subline(line, pat, sub);
		result = get_line(line, MAXSTR);				result = get_line(line, MAXSTR);
	}								}
}								}
main(argc, argv)						main(argc, argv)
							      |	int argc;
char *argv[];							char *argv[];
{								{
	string pat, sub;						string pat, sub;
	bool result;							bool result;
	if (argc < 2) {					      |		;

		exit(1);				      |
	}						      |		 
	result = getpat(argv[1], pat);					result = getpat(argv[1], pat);
	if (!result) {							if (!result) {
							      |			                                             
		exit(2);							exit(2);
	}								}
	if (argc >= 3) {						if (argc >= 3) {
		result = getsub(argv[2], sub);					result = getsub(argv[2], sub);
		if (!result) {							if (!result) {
							      |				                                     
			exit(3);							exit(3);
		}								}
							      |		} else{
							      |			             ;
	}								}
	change(pat, sub);						change(pat, sub);
							      |		          ;
}								}
							      |	void
Caseerror(n)							Caseerror(n)
							      |	int n;
{								{
							      |		                                                     
							      |		       ;
}								}
