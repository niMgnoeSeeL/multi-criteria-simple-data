====2
1:1c
3:1c
  extern void exit();
2:1c
  
====2
1:3c
3:3c
  void Caseerror();
2:3c
  
====2
1:7c
3:7c
  # define NULL		0
2:7c
  
====2
1:26c
3:26c
  typedef char	character;
2:26c
  
====2
1:31c
3:31c
  int maxsize;
2:31c
  
====3
1:34,35c
2:34,35c
  	result = fgets(s, maxsize, stdin);
  	return (result != NULL);
3:34,35c
  	                                 ;
  	                       ;
====2
1:37c
3:37c
  int
2:37c
  
====2
1:42c
3:42c
  int maxset;
2:42c
  
====3
1:45,48c
2:45,48c
  	if (*j >= maxset) {
  		result = false;
  	} else{
  		outset[*j] = c;
3:45,48c
  	if (*j >= maxset) ;
  
  	  else{
  		              ;
====3
1:50c
2:50c
  		result = true;
3:50c
  		             ;
====3
1:52c
2:52c
  	return (result);
3:52c
  	               ;
====3
1:60,64c
2:60,64c
  	if (s[*i] != ESCAPE) {
  		result = s[*i];
  	} else {if (s[*i + 1] == ENDSTR) {
  		result = ESCAPE;
  	} else{
3:60,64c
  	if (s[*i] != ESCAPE) ;
  
  	  else {if (s[*i + 1] == ENDSTR) ;
  
  	  else{
====
1:66,77c
  		if (s[*i] == 'n') {
  			result = NEWLINE;
  		} else {if (s[*i] == 't') {
  			result = TAB;
  		} else{
  			result = s[*i];
  		}}
  	}}
  	return (result);
  }
  void change();
  void
2:66,77c
  		if (s[*i] == 'n') {
  			result = NEWLINE;
  		} else {if (s[*i] == 't') {
  			result = TAB;
  		} else{
  			result = s[*i];
  		}}
  	}}
  	return (result);
  }
  
  
3:66,77c
  		;
  
  
  
  
  
  		  
  	}}
  	               ;
  }
  void change();
  void
====2
1:84c
3:84c
  int maxset;
2:84c
  
====3
1:90,93c
2:90,93c
  		if (src[*i - 1] == ESCAPE) {
  			escjunk = esc(src, i);
  			junk = addstr(escjunk, dest, j, maxset);
  		} else {if (src[*i] != DASH)    {
3:90,93c
  		if (src[*i - 1] == ESCAPE) ;
  
  
  		  else {if (src[*i] != DASH)    {
====3
1:95,97c
2:95,97c
  		} else {if ((*j <= 1) || (src[*i + 1] == ENDSTR)) {
  			junk = addstr(DASH, dest, j, maxset);
  		} else {if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1])) &&
3:95,97c
  		} else {if ((*j <= 1) || (src[*i + 1] == ENDSTR)) ;
  
  		  else {if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1])) &&
====3
1:103,105c
2:103,105c
  		}else      {
  			junk = addstr(DASH, dest, j, maxset);
  		}}}}
3:103,105c
  		}else      ;
  
  		 }}}
====3
1:119,122c
2:119,122c
  	if (arg[*i] == NEGATE) {
  		junk = addstr(NCCL, pat, j, MAXPAT);
  		*i = *i + 1;
  	} else{
3:119,122c
  	if (arg[*i] == NEGATE) ;
  
  
  	  else{
====3
1:128,129c
2:128,129c
  	pat[jstart] = *j - jstart - 1;
  	return (arg[*i] == CCLEND);
3:128,129c
  	                             ;
  	                          ;
====2
1:135c
3:135c
  int lastj;
2:135c
  
====
1:141,143c
  		jt = jp + CLOSIZE;
  		junk = addstr(pat[jp], pat, &jt, MAXPAT);
  	}
2:141,143c
  		jt = jp + CLOSIZE;
  		junk = addstr(pat[jp], pat, &jt, MAXPAT);
  }
3:141,143c
  		                 ;
  		                                        ;
  	}
====2
1:148c
3:148c
  char c;
2:148c
  
====3
1:155,156c
2:155,156c
  	return (c == LITCHAR || c == BOL || c == EOL || c == ANY ||
  	       c == CCL || c == NCCL || c == CLOSURE);
3:155,156c
  	;
  	                                              
====2
1:158c
3:158c
  int
2:158c
  
====2
1:161c
3:161c
  int start;
2:161c
  
====2
1:165c
3:165c
  	int result;
2:165c
  
====
1:171,173c
  	i = start;
  	lastj = 0;
  	done = false;
2:171,173c
  	i = start;
  	lastj = 0;
  
3:171,173c
  	         ;
  	         ;
  	done = false;
====
1:180,182c
  		} else {if ((arg[i] == EOL) && (arg[i+1] == delim)) {
  			junk = addstr(EOL, pat, &j, MAXPAT);
  		} else {if ((arg[i] == CCL)) {
2:180,182c
  		} else {if ((arg[i] == EOL) && (arg[i+1] == delim)) {
  
  		} else {if ((arg[i] == CCL)) {
3:180,182c
  		} else {if ((arg[i] == EOL) && (arg[i+1] == delim)) ;
  
  		  else {if ((arg[i] == CCL)) {
====
1:184c
  			done = (bool)(getres == false);
2:184c
  
3:184c
  			                              ;
====
1:187,189c
  			if (in_set_2(pat[lj])) {
  				done = true;
  			} else{
2:187,189c
  			if (in_set_2(pat[lj])) {
  
  			} else{
3:187,189c
  			if (in_set_2(pat[lj])) ;
  
  			  else{
====
1:202,210c
  	junk = addstr(ENDSTR, pat, &j, MAXPAT);
  	if ((done) || (arg[i] != delim)) {
  		result = 0;
  	} else {if ((!junk)) {
  		result = 0;
  	} else{
  		result = i;
  	}}
  	return (result);
2:202,210c
  
  
  
  
  
  
  
  
  
3:202,210c
  	                                      ;
  	if ((done) || (arg[i] != delim)) ;
  
  	  else ;
  
  
  
  	  
  	               ;
====2
1:212c
3:212c
  int
2:212c
  
====
1:219c
  	return (makeres > 0);
2:219c
  
3:219c
  	                    ;
====2
1:221c
3:221c
  int
2:221c
  
====2
1:224,226c
3:224,226c
  int from;
  character delim;
  char *sub;
2:224,226c
  
  
  
====2
1:228c
3:228c
  	int result;
2:228c
  
====
1:230,253c
  	bool junk;
  	character escjunk;
  	j = 0;
  	i = from;
  	while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
  		if ((arg[i] == (unsigned)('&'))) {
  			junk = addstr(DITTO, sub, &j, MAXPAT);
  		} else{
  			escjunk = esc(arg, &i);
  			junk = addstr(escjunk, sub, &j, MAXPAT);
  		}
  		i = i + 1;
  	}
  	if (arg[i] != delim) {
  		result = 0;
  	} else{
  		junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
  		if ((!junk)) {
  			result = 0;
  		} else{
  			result = i;
  		}
  	}
  	return (result);
2:230,253c
  
  
  
  
  	while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
  		if ((arg[i] == (unsigned)('&'))) {
  
  
  
  
  		}
  
  
  
  
  
  
  
  
  
  
  
  	}
  
3:230,253c
  	bool junk;
  	character escjunk;
  	     ;
  	        ;
  	;
  
  
  
  
  
  
  
  	                                                                                                         
  	;
  
  
  
  
  
  
  
  
  	 
  	               ;
====2
1:255c
3:255c
  bool
2:255c
  
====2
1:257,258c
3:257,258c
  char *arg;
  char *sub;
2:257,258c
  
  
====
1:260,262c
  	int makeres;
  	makeres = makesub(arg, 0, ENDSTR, sub);
  	return (makeres > 0);
2:260,262c
  
  
  
3:260,262c
  	int makeres;
  	                                      ;
  	                    ;
====2
1:264,265c
3:264,265c
  void subline();
  bool
2:264,265c
  
  
====2
1:267c
3:267c
  character c;
2:267c
  
====2
1:269c
3:269c
  int offset;
2:269c
  
====
1:272,283c
  	bool flag;
  	flag = false;
  	i = offset + pat[offset];
  	while ((i > offset)) {
  		if (c == pat[i]) {
  			flag = true;
  			i = offset;
  		} else{
  			i = i - 1;
  		}
  	}
  	return (flag);
2:272,283c
  
  
  
  	while ((i > offset)) {
  
  
  
  
  
  
  	}
  
3:272,283c
  	bool flag;
  	            ;
  	                        ;
  	;
  
  
  
  
  
  
  	                                                                                                           
  	             ;
====2
1:285c
3:285c
  bool
2:285c
  
====2
1:290c
3:290c
  int j;
2:290c
  
====
1:292,344c
  	char advance;
  	bool result;
  	advance = -1;
  	if ((lin[*i] == ENDSTR)) {
  		result = false;
  	} else{
  		if (!in_pat_set(pat[j])) {
  			(void)fprintf(stdout, "in omatch: can't happen\n");
  			abort();
  		} else{
  			switch (pat[j]) {
  			case LITCHAR:
  				if (lin[*i] == pat[j + 1]) {
  					advance = 1;
  				}
  				break;
  			case BOL:
  				if (*i == 0) {
  					advance = 0;
  				}
  				break;
  			case ANY:
  				if (lin[*i] != NEWLINE) {
  					advance = 1;
  				}
  				break;
  			case EOL:
  				if (lin[*i] == NEWLINE) {
  					advance = 0;
  				}
  				break;
  			case CCL:
  				if (locate(lin[*i], pat, j + 1)) {
  					advance = 1;
  				}
  				break;
  			case NCCL:
  				if ((lin[*i] != NEWLINE) && (!locate(lin[*i], pat, j+1))) {
  					advance = 1;
  				}
  				break;
  			default:
  				Caseerror(pat[j]);
  			}
  		}
  	}
  	if ((advance >= 0)) {
  		*i = *i + advance;
  		result = true;
  	} else{
  		result = false;
  	}
  	return (result);
2:292,344c
  
  
  
  	if ((lin[*i] == ENDSTR)) {
  
  
  		if (!in_pat_set(pat[j])) {
  
  
  
  			switch (pat[j]) {
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  			}
  		}
  
  
  
  
  
  
  	}
  
3:292,344c
  	char advance;
  	bool result;
  	            ;
  	;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  	 
  	;
  
  
  
  
  	 
  	               ;
====2
1:348c
3:348c
  int n;
2:348c
  
====
1:350,375c
  	int size;
  	if (!in_pat_set(pat[n])) {
  		(void)fprintf(stdout, "in patsize: can't happen\n");
  		abort();
  	} else{
  		switch (pat[n]) {
  		case LITCHAR:
  			size = 2;
  			break;
  		case BOL:
  		case EOL:
  		case ANY:
  			size = 1;
  			break;
  		case CCL:
  		case NCCL:
  			size = pat[n + 1] + 2;
  			break;
  		case CLOSURE:
  			size = CLOSIZE;
  			break;
  		default:
  			Caseerror(pat[n]);
  		}
  	}
  	return (size);
2:350,375c
  
  	if (!in_pat_set(pat[n])) {
  
  
  
  		switch (pat[n]) {
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  		}
  	}
  
3:350,375c
  	int size;
  	;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  	 
  	             ;
====2
1:377c
3:377c
  int
2:377c
  
====2
1:380c
3:380c
  int offset;
2:380c
  
====2
1:382c
3:382c
  int j;
2:382c
  
====
1:386,423c
  	done = false;
  	while ((!done) && (pat[j] != ENDSTR)) {
  		if ((pat[j] == CLOSURE)) {
  			j = j + patsize(pat, j);
  			i = offset;
  			while ((!done) && (lin[i] != ENDSTR)) {
  				result = omatch(lin, &i, pat, j);
  				if (!result) {
  					done = true;
  				}
  			}
  			done = false;
  			while ((!done) && (i >= offset)) {
  				k = amatch(lin, i, pat, j + patsize(pat, j));
  				if ((k >= 0)) {
  					done = true;
  				} else{
  					i = i - 1;
  				}
  			}
  			offset = k;
  			done = true;
  		} else {
  			result = omatch(lin, &offset, pat, j);
  			if ((!result)) {
  				offset = -1;
  				done = true;
  			} else{
  				j = j + patsize(pat, j);
  			}
  		}
  	}
  	return (offset);
  }
  void
  putsub(lin, s1, s2, sub)
  char *lin;
  int s1, s2;
2:386,423c
  
  	while ((!done) && (pat[j] != ENDSTR)) {
  		if ((pat[j] == CLOSURE)) {
  
  
  			while ((!done) && (lin[i] != ENDSTR)) {
  
  
  
  
  
  
  
  
  
  
  
  
  
  			}
  
  
  
  
  
  
  
  
  
  
  		}
  	}
  
  }
  
  putsub(lin, s1, s2, sub)
  
  
3:386,423c
  	            ;
  	;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  	                                                                                                       
  	return (offset);
  }
  void
  putsub(lin, s1, s2, sub)
  char *lin;
  int s1, s2;
====
1:427,438c
  	int j;
  	i = 0;
  	while ((sub[i] != ENDSTR)) {
  		if ((sub[i] == DITTO)) {
  			for (j = s1; j < s2; j++) {
  				fputc(lin[j], stdout);
  			}
  		} else{
  			fputc(sub[i], stdout);
  		}
  		i = i + 1;
  	}
2:427,438c
  
  
  	while ((sub[i] != ENDSTR)) {
  		if ((sub[i] == DITTO)) {
  
  
  
  
  
  		}
  
  	}
3:427,438c
  	int j;
  	     ;
  	;
  
  
  
  
  
  
  
  
  	                                                 
====2
1:440c
3:440c
  void
2:440c
  
====2
1:443,444c
3:443,444c
  char *pat;
  char *sub;
2:443,444c
  
  
====
1:447,461c
  	lastm = -1;
  	i = 0;
  	while ((lin[i] != ENDSTR)) {
  		m = amatch(lin, i, pat, 0);
  		if ((m >= 0) && (lastm != m)) {
  			putsub(lin, i, m, sub);
  			lastm = m;
  		}
  		if ((m == -1) || (m == i)) {
  			fputc(lin[i], stdout);
  			i = i + 1;
  		} else{
  			i = m;
  		}
  	}
2:447,461c
  
  
  	while ((lin[i] != ENDSTR)) {
  
  
  
  
  
  
  
  
  
  
  
  	}
3:447,461c
  	          ;
  	     ;
  	;
  
  
  
  
  
  
  
  
  
  
  
  	                                                 
====2
1:463c
3:463c
  void
2:463c
  
====2
1:465c
3:465c
  char *pat, *sub;
2:465c
  
====2
1:467c
3:467c
  	string line;
2:467c
  
====
1:469,473c
  	result = get_line(line, MAXSTR);
  	while ((result)) {
  		subline(line, pat, sub);
  		result = get_line(line, MAXSTR);
  	}
2:469,473c
  
  	while ((result)) {
  
  
  	}
3:469,473c
  	                               ;
  	;
  
  
  	                                                           
====2
1:476c
3:476c
  int argc;
2:476c
  
====
1:481,484c
  	if (argc < 2) {
  		(void)fprintf(stdout, "usage: change from [to]\n");
  		exit(1);
  	}
2:481,484c
  
  
  
  
3:481,484c
  	;
  
  
  	 
====
1:486,500c
  	if (!result) {
  		(void)fprintf(stdout, "change: illegal \"from\" pattern\n");
  		exit(2);
  	}
  	if (argc >= 3) {
  		result = getsub(argv[2], sub);
  		if (!result) {
  			(void)fprintf(stdout, "change: illegal \"to\" string\n");
  			exit(3);
  		}
  	} else{
  		sub[0] = '\0';
  	}
  	change(pat, sub);
  	return (0);
2:486,500c
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
3:486,500c
  	;
  
  
  	 
  	;
  
  
  
  
  
  
  
  	 
  	                ;
  	          ;
====2
1:502c
3:502c
  void
2:502c
  
====2
1:504c
3:504c
  int n;
2:504c
  
====
1:506,507c
  	(void)fprintf(stdout, "Missing case limb: line %d\n", n);
  	exit(4);
2:506,507c
  
  
3:506,507c
  	                                                                                                        ;
  	       ;
